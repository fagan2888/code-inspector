//	Data Block class
//
//	Used for storing variable-size blocks of data
//	--------------------------------------------------------------------------------
//	Porrima Hex Editor
//	Copyright (C) 2008-2010 Stanislav Vorobyev <mailto:stanislav.vorobyev@gmail.com>
//
//	This program is free software: you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation, either version 3 of the License, or
//	(at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program.  If not, see <http://www.gnu.org/licenses/>.
//	--------------------------------------------------------------------------------
//	$Id: DataBlock.cs 18 2010-09-14 19:09:09Z stanislav.vorobyev $

using System;
using System.Collections.Generic;

namespace Porrima.Core.Storage
{
	/// <summary>
	/// ???? ?????? ? ???????????? ????????? ???????
	/// </summary>
	/// <remarks>
	/// ?????? ? ??????? ? ????? ??????? "???????", ????????? ???????? ???????????? ??????????? ???????? ??????.
	/// </remarks>
	[Serializable]
	public class DataBlock : ICloneable, IEquatable<DataBlock>, IEqualityComparer<DataBlock>
	{
		#region Variables
		
		/// <summary>
		/// ?????? ?????????? ??????
		/// </summary>
		private int size;

		/// <summary>
		/// ???????? ??????
		/// </summary>
		private int offset;

		#endregion

		#region Properties

		/// <summary>
		/// ?????? ??? ????? ??????
		/// </summary>
		public byte[] Data
		{
			get;
			set;
		}

		/// <summary>
		/// ???????? ????? ????? ??????????? ?????
		/// </summary>
		/// <remarks>
		/// ????? ???? ?? ????????? ?????
		/// </remarks>
		public int EndOffset
		{
			get
			{
				return offset + size;
			}
		}

		/// <summary>
		/// ??????? ???? ???????? ? ????? ?????
		/// </summary>
		public int FreeBytesAtEnd
		{
			get
			{
				return Data.Length - EndOffset;
			}
		}

		/// <summary>
		/// ?????? ?????????? ??????
		/// </summary>
		/// <remarks>
		/// ??????????? ???????? ?????? ?????? ? ??????? ???????
		/// </remarks>
		/// <exception cref="ArgumentOutOfRangeException">?????????, ???? ??? ?????? ???????????? ?????</exception>
		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				if (value + offset > Data.Length || value < 0)
					throw new ArgumentOutOfRangeException("value", value, ErrorMessages.ErrorValueOutOfRange);
				size = value;
			}
		}

		/// <summary>
		/// ?????? ?????
		/// </summary>
		/// <remarks>
		/// ??? ????????? ??????? ????? ?????????, ??? ???????? ?????? ???????????.
		/// </remarks>
		/// <exception cref="ArgumentOutOfRangeException">?????????, ???? ??? ?????? ???????????? ?????</exception>
		public int Capacity
		{
			get
			{
				return Data.Length;
			}
			set
			{
				if (offset + size > value || value <= 0)
					throw new ArgumentOutOfRangeException("value", value, ErrorMessages.ErrorValueOutOfRange);
				if (Data.Length == value) return;
				// ????????? ????????? ?????
				var newData = new byte[value];
				Buffer.BlockCopy(Data, 0, newData, 0, Math.Min(Data.Length, newData.Length));
				Data = newData;
			}
		}

		/// <summary>
		/// ???????? ?????? ?? ?????? ?????
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">?????????, ???? ??? ?????? ???????????? ?????</exception>
		public int Offset
		{
			get
			{
				return offset;
			}
			set
			{
				if (value + size > Data.Length || value < 0)
					throw new ArgumentOutOfRangeException("value", value, ErrorMessages.ErrorValueOutOfRange);
				offset = value;
			}
		}

		#endregion

		#region Comparisons

		/// <summary>
		/// ???????? ?? ?????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ??????? ???? ????????? ?? ???? ? ??? ?? ?????? ??????
		/// </remarks>
		/// <param name="obj">?????? ??????</param>
		/// <returns>?????????</returns>
		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			var db = obj as DataBlock;
			return (object)db != null && db.Data.Equals(Data);
		}

		/// <summary>
		/// ???????? ?? ?????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ??????? ???? ????????? ?? ???? ? ??? ?? ?????? ??????
		/// </remarks>
		/// <param name="other">?????? ??????</param>
		/// <returns>?????????</returns>
		public bool Equals(DataBlock other)
		{
			return (object)other != null && other.Data.Equals(Data);
		}

		/// <summary>
		/// ???????? ?????? ?? ????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ????????, ???? ?????? ? ??? ????????? ?????????
		/// </remarks>
		/// <param name="other">?????? ????</param>
		/// <returns>?????????</returns>
		public bool Similar(DataBlock other)
		{
			if (other == null)
				return false;
			if (other.Size != size)
				return false;
			for (var i = 0; i < size; i++)
				if (other[i] != this[i])
					return false;
			return true;
		}

		/// <summary>
		/// ???????? ?????? ?? ????????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ???????????, ???? ??????? ??????, ?????? ? ???????? ????????? ? ?????? ? ?????? ????????? ?????????
		/// </remarks>
		/// <param name="other">?????? ????</param>
		/// <returns>?????????</returns>
		public bool Identical(DataBlock other)
		{
			if (other == null)
				return false;
			if (other.Size != size)
				return false;
			if (other.Capacity != Data.Length)
				return false;
			if (other.offset != offset)
				return false;
			for (var i = 0; i < size; i++)
				if (other[i] != this[i])
					return false;
			return true;
		}

		/// <summary>
		/// ???????? ?? ?????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ??????? ???? ????????? ?? ???? ? ??? ?? ?????? ??????
		/// </remarks>
		/// <param name="one">?????? ????</param>
		/// <param name="another">?????? ????</param>
		/// <returns>?????????</returns>
		public static bool operator==(DataBlock one, DataBlock another)
		{
			if ((object)one == null && (object)another == null)
				return true;
			return (object)one != null ? one.Equals(another) : another.Equals(one);
		}

		/// <summary>
		/// ???????? ?? ???????????
		/// </summary>
		/// <remarks>
		/// ????? ????????? ??????? ???? ????????? ?? ???? ? ??? ?? ?????? ??????
		/// </remarks>
		/// <param name="one">?????? ????</param>
		/// <param name="another">?????? ????</param>
		/// <returns>?????????</returns>
		public static bool operator!=(DataBlock one, DataBlock another)
		{
			return !(one == another);
		}

		/// <summary>
		/// ??????? ???
		/// </summary>
		/// <returns>???</returns>
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		#endregion

		#region Methods

		/// <summary>
		/// ?????????? ??? ??????? ? ??????
		/// </summary>
		/// <param name="offs">????????</param>
		/// <returns>??????? ??????</returns>
		/// <exception cref="ArgumentOutOfRangeException">????????? ???? ?????? ?? ??????????? ???????? ???????</exception>
		public byte this[int offs]
		{
			get
			{
				if (offs + offset >= Data.Length || offs < 0)
					throw new ArgumentOutOfRangeException("offs", offs, ErrorMessages.ErrorValueOutOfRange);
				return Data[offs + offset];
			}
			set
			{
				if (offs + offset >= Data.Length || offs < 0)
					throw new ArgumentOutOfRangeException("offs", offs, ErrorMessages.ErrorValueOutOfRange);
				Data[offs + offset] = value;
			}
		}

		/// <summary>
		/// ????????? ????????? ??????
		/// </summary>
		/// <param name="buffer">?????</param>
		/// <param name="offset">????????</param>
		/// <param name="count">????? ????</param>
		public static Exception CheckBufferArguments(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
				return new ArgumentNullException("buffer", ErrorMessages.ErrorNullValue);
			if (offset < 0 || offset >= buffer.Length && buffer.Length > 0)
				return new ArgumentOutOfRangeException("offset", offset, ErrorMessages.ErrorValueOutOfRange);
			if (count < 0 || offset + count > buffer.Length)
				return new ArgumentOutOfRangeException("count", count, ErrorMessages.ErrorValueOutOfRange);
			return null;
		}

		/// <summary>
		/// ???????? ?????? ? ????? ?????
		/// </summary>
		/// <param name="buffer">?????</param>
		/// <param name="offs">???????? ? ??????</param>
		/// <param name="count">??????</param>
		/// <returns>????? ??????????? ????</returns>
		/// <exception cref="ArgumentOutOfRangeException">?????????, ???? ?????? ???????? ????????? ??????</exception>
		/// <exception cref="ArgumentNullException">?????????, ???? buffer == null</exception>
		public int Append(byte[] buffer, int offs, int count)
		{
			var check = CheckBufferArguments(buffer, offs, count);
			if (check != null)
				throw check;
			// ???? ?????? ?? ??????????, ??????????? ?????
			if (count > FreeBytesAtEnd)
				count = FreeBytesAtEnd;
			if (count == 0)
				return 0;
			// ??????????? ? ????????? ??????
			Buffer.BlockCopy(buffer, offs, Data, EndOffset, count);
			size += count;
			return count;
		}

		#endregion

		#region Constructors

		/// <summary>
		/// ??????????? ?????
		/// </summary>
		/// <remarks>
		/// ?? ????????? ???? ????????? ??????
		/// </remarks>
		/// <param name="capacity">?????? ?????</param>
		/// <exception cref="ArgumentOutOfRangeException">????????? ???? capacity &lt;= 0</exception>
		public DataBlock(int capacity)
		{
			if (capacity <= 0)
				throw new ArgumentOutOfRangeException("capacity", capacity, ErrorMessages.ErrorValueOutOfRange);
			Data = new byte[capacity];
		}

		/// <summary>
		/// ??????????? ????? ?? ?????? ? ???????? ??????? ?????
		/// </summary>
		/// <param name="buffer">?????</param>
		/// <param name="offset">???????? ? ??????</param>
		/// <param name="count">?????? ??????</param>
		/// <param name="capacity">?????? ?????</param>
		/// <exception cref="System.ArgumentOutOfRangeException">?????????, ???? ?????? ???????? ????????? ?????? ??? ????? ????</exception>
		/// <exception cref="System.ArgumentNullException">?????????, ???? buffer == null</exception>
		public DataBlock(int capacity, byte[] buffer, int offset, int count)
			: this(capacity)
		{
			var check = CheckBufferArguments(buffer, offset, count);
			if (check != null)
				throw check;
			if (count > capacity)
				throw new ArgumentException(ErrorMessages.ErrorWrongValue, "capacity");
			size = count;
			Buffer.BlockCopy(buffer, offset, Data, 0, count);
		}

		/// <summary>
		/// ??????????? ????? ?? ??????
		/// </summary>
		/// <param name="buffer">?????</param>
		/// <param name="offset">???????? ? ??????</param>
		/// <param name="length">?????? ??????</param>
		/// <exception cref="System.ArgumentOutOfRangeException">?????????, ???? ?????? ???????? ????????? ?????? ??? ????? ????</exception>
		/// <exception cref="System.ArgumentNullException">?????????, ???? buffer == null</exception>
		public DataBlock(byte[] buffer, int offset, int length)
			: this(buffer != null ? buffer.Length : 1, buffer, offset, length)
		{
		}

		/// <summary>
		/// ??????????? ????? ?? ??????
		/// </summary>
		/// <param name="buffer">?????</param>
		/// <exception cref="System.ArgumentOutOfRangeException">?????????, ???? ????? ????</exception>
		/// <exception cref="System.ArgumentNullException">?????????, ???? buffer == null</exception>
		public DataBlock(byte[] buffer)
			: this(buffer != null ? buffer.Length : 1, buffer, 0, buffer != null ? buffer.Length : 0)
		{
		}

		#endregion

		#region ICloneable Members

		/// <summary>
		/// ???????? ????? ???????? ??????
		/// </summary>
		/// <remarks>
		/// ?????? ?????????? ?????? ?? ??????????? ??????? ?????
		/// </remarks>
		/// <returns>?????</returns>
		public object Clone()
		{
			var db = new DataBlock(Data.Length);
			Buffer.BlockCopy(Data, offset, db.Data, offset, size);
			db.Offset = offset;
			db.Size = size;
			return db;
		}

		#endregion

		#region IEqualityComparer<DataBlock> Members

		/// <summary>
		/// ????????? ???? ??????
		/// </summary>
		/// <param name="x">?????? ????</param>
		/// <param name="y">?????? ????</param>
		/// <returns>?????????</returns>
		public bool Equals(DataBlock x, DataBlock y)
		{
			if (x == null)
				throw new ArgumentNullException("x");
			return x.Equals(y);
		}

		/// <summary>
		/// ???????? ???-??? ?????
		/// </summary>
		/// <param name="obj">????</param>
		/// <returns>?????????</returns>
		public int GetHashCode(DataBlock obj)
		{
			if (obj == null)
				throw new ArgumentNullException("obj");
			return obj.GetHashCode();
		}

		#endregion
	}
}
